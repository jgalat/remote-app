diff --git a/node_modules/@ctrl/magnet-link/bep53.d.ts b/node_modules/@ctrl/magnet-link/bep53.d.ts
new file mode 100644
index 0000000..aeb1ee1
--- /dev/null
+++ b/node_modules/@ctrl/magnet-link/bep53.d.ts
@@ -0,0 +1,2 @@
+export declare function composeRange(range: number[]): string[];
+export declare function parseRange(range: string[]): number[];
diff --git a/node_modules/@ctrl/magnet-link/bep53.js b/node_modules/@ctrl/magnet-link/bep53.js
new file mode 100644
index 0000000..ae52add
--- /dev/null
+++ b/node_modules/@ctrl/magnet-link/bep53.js
@@ -0,0 +1,20 @@
+export function composeRange(range) {
+    return range
+        .reduce((acc, cur, idx, arr) => {
+        if (idx === 0 || cur !== arr[idx - 1] + 1) {
+            acc.push([]);
+        }
+        acc[acc.length - 1].push(`${cur}`);
+        return acc;
+    }, [])
+        .map(cur => {
+        return cur.length > 1 ? `${cur[0]}-${cur[cur.length - 1]}` : `${cur[0]}`;
+    });
+}
+export function parseRange(range) {
+    const generateRange = (start, end = start) => Array.from({ length: end - start + 1 }, (_, idx) => idx + start);
+    return range.reduce((acc, cur) => {
+        const r = cur.split('-').map(cur => parseInt(cur, 10));
+        return acc.concat(generateRange(r[0], r[1]));
+    }, []);
+}
diff --git a/node_modules/@ctrl/magnet-link/index.d.ts b/node_modules/@ctrl/magnet-link/index.d.ts
new file mode 100644
index 0000000..1931e92
--- /dev/null
+++ b/node_modules/@ctrl/magnet-link/index.d.ts
@@ -0,0 +1,74 @@
+/// <reference types="node" resolution-mode="require"/>
+export interface MagnetData {
+    /**
+     * Is the info-hash hex encoded, for a total of 40 characters. For compatability with existing links in the wild, clients should also support the 32 character base32 encoded info-hash.
+     *
+     * *or*
+     *
+     * Is the multihash formatted, hex encoded full infohash for torrents in the new metadata format. 'btmh' and 'btih' exact topics may exist in the same magnet if they describe the same hybrid torrent.
+     * @link http://www.bittorrent.org/beps/bep_0009.html
+     */
+    xt?: string | string[];
+    /**
+     * Parsed xt= parameter see xt
+     */
+    infoHash?: string;
+    infoHashBuffer?: Buffer;
+    infoHashV2?: string;
+    infoHashV2Buffer?: Buffer;
+    /**
+     * The display name that may be used by the client to display while waiting for metadata
+     */
+    name?: string | string[];
+    /**
+     * The display name that may be used by the client to display while waiting for metadata
+     */
+    dn?: string | string[];
+    /**
+     * Tracker url, if there is one. If there are multiple trackers, multiple tr entries may be included
+     */
+    tr?: string | string[];
+    /**
+     * Tracker url, if there is one. If there are multiple trackers, multiple tr entries may be included
+     */
+    announce?: string[];
+    /**
+     * An array of where the actual torrent file can be downloaded
+     */
+    xs?: string | string[];
+    /**
+     * An array of where the actual torrent file can be downloaded
+     */
+    as?: string | string[];
+    /**
+     * An array of where the actual torrent file can be downloaded
+     */
+    ws?: string | string[];
+    /**
+     * "keyword topic": a more general search, specifying search terms rather than a particular file
+     */
+    kt?: string[];
+    so?: string[] | number[];
+    'x.pe'?: string | string[];
+    /**
+     * "keyword topic": a more general search, specifying search terms rather than a particular file
+     */
+    keywords?: string | string[];
+    /**
+     * File index
+     */
+    ix?: number | number[];
+    /**
+     * Size in bytes
+     */
+    xl?: string;
+    /**
+     * Combined as= and ws= parameters if they exist
+     */
+    urlList?: string[];
+    peerAddresses?: string[];
+    publicKey?: string;
+    publicKeyBuffer?: Buffer;
+}
+export declare function magnetDecode(uri: string): MagnetData;
+export declare function magnetEncode(data: MagnetData): string;
diff --git a/node_modules/@ctrl/magnet-link/index.js b/node_modules/@ctrl/magnet-link/index.js
new file mode 100644
index 0000000..347b2cb
--- /dev/null
+++ b/node_modules/@ctrl/magnet-link/index.js
@@ -0,0 +1,219 @@
+import { base32Decode } from '@ctrl/ts-base32';
+import * as bep53Range from './bep53.js';
+const start = 'magnet:?';
+export function magnetDecode(uri) {
+    // Support 'stream-magnet:' as well
+    const data = uri.substr(uri.indexOf(start) + start.length);
+    const params = data && data.length >= 0 ? data.split('&') : [];
+    const result = {};
+    params.forEach(param => {
+        const keyval = param.split('=');
+        // This keyval is invalid, skip it
+        if (keyval.length !== 2) {
+            return;
+        }
+        const key = keyval[0];
+        const val = parseQueryParamValue(key, keyval[1]);
+        if (val === undefined) {
+            return;
+        }
+        const r = result[key];
+        if (!r) {
+            result[key] = val;
+            return result;
+        }
+        // If there are repeated parameters, return an array of values
+        if (r && Array.isArray(r)) {
+            r.push(val);
+            return;
+        }
+        result[key] = [r, val];
+        // eslint-disable-next-line no-useless-return
+        return;
+    });
+    if (result.xt) {
+        let m;
+        const xts = Array.isArray(result.xt) ? result.xt : [result.xt];
+        xts.forEach((xt) => {
+            if ((m = xt.match(/^urn:btih:(.{40})/))) {
+                result.infoHash = m[1].toLowerCase();
+            }
+            else if ((m = xt.match(/^urn:btih:(.{32})/))) {
+                const decodedStr = base32Decode(m[1]);
+                result.infoHash = Buffer.from(decodedStr).toString('hex');
+            }
+            else if ((m = xt.match(/^urn:btmh:1220(.{64})/))) {
+                result.infoHashV2 = m[1].toLowerCase();
+            }
+        });
+    }
+    if (result.xs) {
+        let m;
+        const xss = Array.isArray(result.xs) ? result.xs : [result.xs];
+        xss.forEach(xs => {
+            if ((m = /^urn:btpk:(.{64})/.exec(xs))) {
+                result.publicKey = m[1]?.toLowerCase();
+            }
+        });
+    }
+    if (result.infoHash) {
+        result.infoHashBuffer = Buffer.from(result.infoHash, 'hex');
+    }
+    if (result.infoHashV2) {
+        result.infoHashV2Buffer = Buffer.from(result.infoHashV2, 'hex');
+    }
+    if (result.publicKey) {
+        result.publicKeyBuffer = Buffer.from(result.publicKey, 'hex');
+    }
+    if (result.dn) {
+        result.name = result.dn;
+    }
+    if (result.kt) {
+        result.keywords = result.kt;
+    }
+    if (typeof result.tr === 'string') {
+        result.announce = [result.tr];
+    }
+    else if (Array.isArray(result.tr)) {
+        result.announce = result.tr;
+    }
+    else {
+        result.announce = [];
+    }
+    result.urlList = [];
+    if (typeof result.as === 'string' || Array.isArray(result.as)) {
+        result.urlList = result.urlList.concat(result.as);
+    }
+    if (typeof result.ws === 'string' || Array.isArray(result.ws)) {
+        result.urlList = result.urlList.concat(result.ws);
+    }
+    result.peerAddresses = [];
+    if (typeof result['x.pe'] === 'string' || Array.isArray(result['x.pe'])) {
+        result.peerAddresses = result.peerAddresses.concat(result['x.pe']);
+    }
+    result.announce = [...new Set(result.announce)].sort((a, b) => a.localeCompare(b));
+    result.urlList = [...new Set(result.urlList)].sort((a, b) => a.localeCompare(b));
+    result.peerAddresses = [...new Set(result.peerAddresses)];
+    return result;
+}
+/**
+ * Specific query parameters have expected formats, this attempts to parse them in the correct way
+ */
+function parseQueryParamValue(key, val) {
+    // Clean up torrent name
+    if (key === 'dn') {
+        return decodeURIComponent(val).replace(/\+/g, ' ');
+    }
+    // Address tracker (tr), exact source (xs), and acceptable source (as) are encoded
+    // URIs, so decode them
+    if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {
+        return decodeURIComponent(val);
+    }
+    // Return keywords as an array
+    if (key === 'kt') {
+        return decodeURIComponent(val).split('+');
+    }
+    // bep53
+    if (key === 'so') {
+        return bep53Range.parseRange(decodeURIComponent(val).split(','));
+    }
+    // Cast file index (ix) to a number
+    if (key === 'ix') {
+        return Number(val);
+    }
+    return val;
+}
+export function magnetEncode(data) {
+    const obj = { ...data }; // Shallow clone object
+    // Deduplicate xt by using a set
+    let xts = new Set();
+    if (obj.xt && typeof obj.xt === 'string') {
+        xts.add(obj.xt);
+    }
+    if (obj.xt && Array.isArray(obj.xt)) {
+        xts = new Set(obj.xt);
+    }
+    if (obj.infoHashBuffer) {
+        xts.add(`urn:btih:${obj.infoHashBuffer.toString('hex')}`);
+    }
+    if (obj.infoHash) {
+        xts.add(`urn:btih:${obj.infoHash}`);
+    }
+    if (obj.infoHashV2Buffer) {
+        xts.add((obj.xt = `urn:btmh:1220${obj.infoHashV2Buffer.toString('hex')}`));
+    }
+    if (obj.infoHashV2) {
+        xts.add(`urn:btmh:1220${obj.infoHashV2}`);
+    }
+    const xtsDeduped = Array.from(xts);
+    if (xtsDeduped.length === 1) {
+        obj.xt = xtsDeduped[0];
+    }
+    if (xtsDeduped.length > 1) {
+        obj.xt = xtsDeduped;
+    }
+    // Support using convenience names, in addition to spec names
+    // (example: `infoHash` for `xt`, `name` for `dn`)
+    if (obj.infoHash) {
+        obj.xt = `urn:btih:${obj.infoHash}`;
+    }
+    if (obj.publicKeyBuffer) {
+        obj.xs = `urn:btpk:${obj.publicKeyBuffer.toString('hex')}`;
+    }
+    if (obj.publicKey) {
+        obj.xs = `urn:btpk:${obj.publicKey}`;
+    }
+    if (obj.name) {
+        obj.dn = obj.name;
+    }
+    if (obj.keywords) {
+        obj.kt = obj.keywords;
+    }
+    if (obj.announce) {
+        obj.tr = obj.announce;
+    }
+    if (obj.urlList) {
+        obj.ws = obj.urlList;
+        delete obj.as;
+    }
+    if (obj.peerAddresses) {
+        obj['x.pe'] = obj.peerAddresses;
+    }
+    return Object.keys(obj)
+        .filter(key => key.length === 2 || key === 'x.pe')
+        .reduce((prev, key, i) => {
+        let acc = prev;
+        const values = Array.isArray(obj[key]) ? obj[key] : [obj[key]];
+        values.forEach((val, j) => {
+            if ((i > 0 || j > 0) && ((key !== 'kt' && key !== 'so') || j === 0)) {
+                acc += '&';
+            }
+            if (key === 'dn') {
+                val = encodeURIComponent(val).replace(/%20/g, '+');
+            }
+            if (key === 'tr' || key === 'as' || key === 'ws') {
+                val = encodeURIComponent(val);
+            }
+            // Don't URI encode BEP46 keys
+            if (key === 'xs' && !val.startsWith('urn:btpk:')) {
+                val = encodeURIComponent(val);
+            }
+            if (key === 'kt') {
+                val = encodeURIComponent(val);
+            }
+            if (key === 'so') {
+                return;
+            }
+            if (key === 'kt' && j > 0) {
+                acc += `+${val}`;
+            }
+            else {
+                acc += `${key}=${val}`;
+            }
+        });
+        if (key === 'so') {
+            acc += `${key}=${bep53Range.composeRange(values)}`;
+        }
+        return acc;
+    }, `${start}`);
+}
